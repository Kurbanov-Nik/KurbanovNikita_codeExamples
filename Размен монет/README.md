# "Разменник"
Пример задания, которое выдавалось в институте на парах по программированию на Python. В отличии от большинства других, данное задание было необязательным для выполнения – так сказать задание со звездочкой. По сути, данное задание выполнялось не для отметки в журнале, а для себя лично.
Суть: составить программу, которая будет выводить на экран все возможные варианты размена десятирублевой монеты монетами меньшего номинала (1 руб., 2 руб. и 5 руб.). Дополнительно реализовать вариант с использованием функции-генератора.\
Пример вывода:
```
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2, 1, 1, 1, 1, 1, 1, 1, 1]
[2, 2, 1, 1, 1, 1, 1, 1]
[2, 2, 2, 1, 1, 1, 1]
[2, 2, 2, 2, 1, 1]
[2, 2, 2, 2, 2]
[5, 1, 1, 1, 1, 1]
[5, 2, 1, 1, 1]
[5, 2, 2, 1]
[5, 5]
```
Для данного задания представлено два файла: вариант с использованием функции-генератора (**_money_changer_yields.py_**) и без нее (**_money_changer.py_**). Оба файла отличаются еще и тем, как формируются сами списки размена.В первой программе сначала формируется список из единиц («1»), после чего он итерационно изменяется при помощи операций среза и генератора списков. Во второй программе список используется как своеобразный словарь, где вместо ключей используются индексы, тем самым позволяя хранить информацию о количестве «купюр» разного номинала.
```
# 1ый
exchange = [1 for _ in range(money)]
# --> [1, 1, 1, 1, ...]

# 2ой
exchange = [0 for _ in range(0, max_index + 1)]
exchange[0] = money
# --> [money, 0, 0, 0, ...] --> {“1” : money, “2” : 0, “5” : 0, “10” : 0, ...}
```
Обе программы рассчитаны на размен не только 10 руб., но и произвольной суммы тоже.
## Алгоритм
* В начале определяется сумма (***money***) и список доступных монет/купюр для размена (***banknotes***).
* Затем из списка купюр определяется индекс максимальной купюру (**max_index***), допустимой для размена введенной суммы денег.
* Формируется список из единиц (***exchange***) – базовое и тривиальное разложение суммы.
* Затем в теле цикла от 1 до ***max_index*** данный список преобразуется. Для преобразования используются две основные величины: ***index*** и ***iter***. ***index*** ограничивает допустимые к использованию купюры на заданной итерации. Таким образом сначала в размене участвуют монеты номиналом в «2» руб., затем в размен добавляются монеты в «5» руб., затем в «10» руб. и т. д. ***iter*** предназначен для прогонки всевозможных вариантов в диапазоне купюр от «2» до ***banknotes[index]***.
	* Внутри главного цикла на каждой новой итерации ***iter*** приравнивается ***index***. Таким образом формируется запись размена, где на первом месте будет стоять купюра максимального номинала (на данной итерации), а все остальное – нули.
    * Затем в главном цикле при помощи бесконечного цикла (***while True***) осуществляется прогонка по всевозможным вариантам размена.
    * Если из «1», что лежат в списке размена, можно сформировать купюру ***banknotes[iter]***, то список обрезается до нужной позиции, в которую записывается необходимая купюра, после чего недостающая сумма (до ***money***) заполняется «1».
    * Если сформировать купюру невозможно, то ***iter*** увеличивается на 1 (если это допустимо ограничением по ***index***), после чего список размена обрезается до нужной позиции, а недостающая сумма заполняется «1». В данном случае в список ничего не добавляется – он лишь урезается (очищается он не нужных монет меньшего чем ***banknotes[index]*** номинала).
# Пример
Пусть надо разменять 11 руб. Представим их в виде
```
{“1” : 11, “2” : 0, “5” : 0, “10” : 0} --> [11, 0, 0, 0]
```
Пусть надо разменять 11 руб. Представим их в виде
```
{“1” : 11, “2” : 0, “5” : 0, “10” : 0} --> [11, 0, 0, 0]
```
Пусть в квадратными ***()*** скобками помечается позиция ***index***, а *** * *** - ***iter***.
```
[11, ( 0^ ), 0, 0] --> [9, ( 1^ ), 0, 0] --> [7, ( 2^ ), 0, 0] --> ... --> [1, ( 5^ ), 0, 0]
```
Далее осуществить перевод единиц («1») в двойки («2») невозможно, в следствии чего необходимо перенести ***index*** и ***iter***.
```
[11, 0, ( 0^ ), 0] --> [6, 0^, ( 1 ), 0] --> [4, 1^, ( 1 ), 0] --> ... --> [0, 3^, ( 1 ), 0]
```
Дальше переводить единицы («1»)  в двойки («2»)  не получиться и поэтому необходимо увеличить позицию ***iter*** на единицу, попутно переведя все другие купюры обратно в единицы.
```
[0, 3^, ( 1 ), 0] --> [6, 0, ( 1^ ), 0]
```
Далее из единиц («1») необходимо сформировать пятерку («5»). Как только это произойдет, позиция ***iter*** будет переведена индекс 1 (что соответствует номиналу в «2» руб.).
```
[6, 0, ( 1^ ), 0] --> [1, 0^, ( 2 ), 0]
```
Дальше перевод невозможен. Переводим ***iter*** на одну позицию вперед, попутно переведя все остальные цифры в единицу (в данном случае ничего делать не надо). Поскольку из оставшихся единиц («1») невозможно сформировать пятерку («5»), то переводим ***index*** на новую позицию (вместе с ***iter***).
```
[1, 0^, ( 2 ), 0] --> [1, 0, ( 2^ ), 0] --> [11, 0, 0, ( 0^ )]  [1, 0^, 0, ( 1 )]
```
Сформировав из единиц десятку («1» → «10»), переводим ***iter*** на позицию 1. Поскольку сформировать двойку невозможно, то переводим ***iter*** на одну позицию вперед и т. д.
```
[1, 0^, 0, ( 1 )] --> [1, 0, 0^, ( 1 )] --> [1, 0, 0, ( 1^ )]
```
Поскольку сделать больше ничего нельзя, то выполнение программы завершается. 
